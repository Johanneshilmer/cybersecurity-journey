Automate Cybersecurity Task with Python

Module 1 Intro till Python

Python och programmering:
  Programmering innebÃ¤r att ge datorer instruktioner fÃ¶r att utfÃ¶ra uppgifter. Datorer kommunicerar egentligen i binÃ¤rkod (0 och 1), 
  men programmeringssprÃ¥k som Python gÃ¶r det enklare fÃ¶r mÃ¤nniskor att skriva kod med mindre och mer fÃ¶rstÃ¥elig syntax.

  Python i cybersÃ¤kerhet anvÃ¤nds ofta fÃ¶r att automatisera repetitiva uppgifter, exempelvis:
    ğŸ‘‰Logganalys
    ğŸ‘‰Malwareanalys
    ğŸ‘‰Hantering av accesskontroller
    ğŸ‘‰IntrÃ¥ngsdetektion
    ğŸ‘‰Regelefterlevnad (compliance checks)
    ğŸ‘‰NÃ¤tverksskanning

# Skriver ut hello python
print("Hello Python")

Data typer:
  String:
    "updates needed"
    "20%"
    "5.0"
    "35"
    "**/**/**" 
    ""

  List:
    [12, 36, 54, 1, 7]
    ["eraab", "arusso", "drosas"]
    [True, False, True, True]
    [15, "approved", True, 45.5, False]
    []

  Integer:
    -100 
    -12
    -1
    0
    1
    20
    500 

  Float:
    -2.2
    -1.34
    0.0
    0.34 

  Boolean:
    True
    False

  Tuple:
    ("wjaffrey", "arutley", "dkot")
    (46, 2, 13, 2, 8, 0, 0)
    (True, False, True, True)
    ("wjaffrey", 13, True)

  Set:
    {"jlanksy", "drosas", "nmason"}

  Dictionary:
    { 1: "East",
    2: "West",
    3: "North",
    4: "South" }

  Att se vilken type en variable har anvÃ¤nder vi type()
  username = "johannes"
  print(type(username))
  output => <class 'str'> "alltsÃ¥ string"

Assign och reassign variables i Python
  # Assign "username"
  username = "nzhao"
  print(username)
  output => nzhao

  # ReAssign "username"
  username = "johannes"
  print(username)
  output => johannes

Olika sÃ¤tt att loopa

For loop nummer
  i = 0
  for i in range(11):
    print(i)

  for i in range(0, 5):
    print(i)


For loop lista
  list = ["banan", "Ã¤pple", "mango"]
  for x in list:
    print(x)

While loops

  i = 0
  while i < 5:
      print(i)
      i += 1

Kontrollera loop-exekvering
  ğŸ‘‰break: avbryter loopen helt nÃ¤r ett villkor uppfylls.
  ğŸ‘‰continue: hoppar Ã¶ver den aktuella iterationen och fortsÃ¤tter med nÃ¤sta.

Kort sagt:
  ğŸ‘‰for â†’ iterera genom en sekvens.
  ğŸ‘‰while â†’ upprepa baserat pÃ¥ ett villkor.
  ğŸ‘‰break/continue â†’ styra exekveringen.
  ğŸ‘‰Undvik oÃ¤ndliga loopar om du inte vill att koden ska kÃ¶ra fÃ¶r evigt.

Olika operator och dess mening
> greater than

< less than

>= greater than or equal to

<= less than or equal to

== equal to

!= not equal to



if statements
Ett if-statement anvÃ¤nds fÃ¶r att lÃ¥ta datorn fatta beslut. Det kontrollerar om ett villkor Ã¤r sant eller falskt och kÃ¶r kod endast om villkoret Ã¤r sant.
  HÃ¤r har vi olika if statements med if, if else, if else elif, if and, if not

  if status == 200:
      print("OK")


  if status == 200:
      print("OK")
  else:
      print("check other status")
  
  
  
  if status == 200:
      print("OK")
  elif status == 400:
      print("Bad Request")
  elif status == 500:
      print("Internal Server Error") 
  
  
  if status == 200:
      print("OK")
  elif status == 400:
      print("Bad Request")
  elif status == 500:
      print("Internal Server Error")
  else:
      print("check other status")
  
  
  if status >= 200 and status <= 226:
      print("successful response")
  
  
  if not(status >= 200 and status <= 226):
      print("check status")










Module 2 Write effective Python code

Basic python functions
  Python-funktioner anvÃ¤nds fÃ¶r att Ã¥teranvÃ¤nda kod och effektivisera repetitiva uppgifter, 
  vilket Ã¤r sÃ¤rskilt anvÃ¤ndbart i cybersÃ¤kerhet dÃ¤r man ofta behÃ¶ver analysera loggar och upptÃ¤cka mÃ¶nster som misstÃ¤nkta inloggningsfÃ¶rsÃ¶k.


Built in function
  Ã„r funktioner som kommer som default i python som tillexempel print(), type(), sorted() och max()

User-defined functions
  Ã„r funtioner som anvÃ¤ndaren sjÃ¤lv har designat.


ğŸ‘‰Exempel pÃ¥ en funktion
def greet_employee():
  print("Welcome! You're inlogged in.")

ğŸ‘‰Kallar vi pÃ¥ vÃ¥r funtion
greet_employee()


Argument
  Ã„r data som tillsÃ¤tts till en funktion nÃ¤r funktionen kallas.

ğŸ‘‰Exempel pÃ¥ en funktion med parametrar
def greet_employee(name):
  print("Welcome!", name)

ğŸ‘‰Kallar vi pÃ¥ vÃ¥r funtion med ett argument
greet_employee("Johannes")



Return statement
  Ã„r statement som exekverar inom en funktion och som skickar ut infromationen nÃ¤r funktionen kallas.

ğŸ‘‰Exempel pÃ¥ en funktion med statement
def calculate_fails(total_attempts, failed_attemts):
  fail_percentage = failed_attemts / total_attempts
  return fail_percentage

ğŸ‘‰Kallar vi pÃ¥ vÃ¥r funtion med statements
calculate_fails(4,2)
output => 0.5

ğŸ‘‰Vi kan ocksÃ¥ spara output i en variable som detta exempel:
percentage = calculate_fails(4,2)


I Python anvÃ¤nds parametrar (variabler i funktionsdefinitionen) och argument (vÃ¤rden som skickas in vid funktionsanrop) fÃ¶r att arbeta med data i funktioner. 
FÃ¶r att returnera resultat anvÃ¤nds return-satser, vilket gÃ¶r det mÃ¶jligt att lagra och Ã¥teranvÃ¤nda vÃ¤rden i andra delar av koden.

Variabler i funktioner kan vara:
  ğŸ‘‰Globala variabler â€“ definieras utanfÃ¶r funktioner och kan nÃ¥s i hela programmet.
  ğŸ‘‰Lokala variabler â€“ skapas inuti funktioner och existerar bara medan funktionen kÃ¶rs.

Parametrar och andra variabler i en funktion Ã¤r alltid lokala. Om en lokal variabel har samma namn som en global, kommer funktionen att anvÃ¤nda den lokala versionen, 
vilket kan skapa fÃ¶rvirring.
ğŸ‘‰BÃ¤sta praxis: undvik att blanda globala och lokala variabler. AnvÃ¤nd parametrar fÃ¶r att skicka in data i funktioner i stÃ¤llet fÃ¶r globala variabler.


Python standard modules and libraries
  En modules Ã¤r en Python-fil som innehÃ¥ller ytterligare funktioner, variabler och andra typer av kÃ¶rbar kod. Ett Python-libraries Ã¤r en samling moduler.
  I Python kan du anvÃ¤nda moduler (enskilda filer med funktioner, variabler och klasser) och bibliotek (samlingar av moduler) fÃ¶r att Ã¥teranvÃ¤nda fÃ¤rdig kod.
  Python Standard Library innehÃ¥ller mÃ¥nga fÃ¤rdiga moduler, t.ex.
    ğŸ‘‰re fÃ¶r mÃ¶nstersÃ¶kning i loggar
    ğŸ‘‰csv fÃ¶r arbete med CSV-filer
    ğŸ‘‰glob och os fÃ¶r kommandoradsinteraktion
    ğŸ‘‰time och datetime fÃ¶r tidsdata
    ğŸ‘‰statistics fÃ¶r berÃ¤kningar som medelvÃ¤rde (mean()) och median (median())
  Importera moduler:
    ğŸ‘‰import modulnamn â€“ importerar hela modulen (t.ex. import statistics â†’ anvÃ¤nd statistics.mean())
    ğŸ‘‰from modulnamn import funktion â€“ importerar en specifik funktion (t.ex. from statistics import mean, median â†’ anvÃ¤nd mean() direkt)
  Externa bibliotek: MÃ¥ste installeras innan de kan importeras. Exempel:
    ğŸ‘‰BeautifulSoup fÃ¶r HTML-parsning
    ğŸ‘‰NumPy fÃ¶r matematiska berÃ¤kningar och arrayer
    ğŸ‘‰Installering gÃ¶rs via t.ex. %pip install numpy, dÃ¤refter kan man importera med import numpy.
ğŸ‘‰ Kort sagt: Standardbiblioteket ger fÃ¤rdig kod direkt i Python, medan externa bibliotek mÃ¥ste installeras. Import gÃ¶rs antingen av hela moduler eller av enskilda funktioner.


FÃ¶r att skriva lÃ¤sbar och korrekt Python-kod Ã¤r det viktigt att fÃ¶lja PEP 8-stilguiden.
  Kommentarer:
    ğŸ‘‰FÃ¶rklara vad koden gÃ¶r, bÃ¥de i bÃ¶rjan och i mer komplexa delar.
    ğŸ‘‰Enradiga kommentarer bÃ¶rjar med # och bÃ¶r hÃ¥llas under 79 tecken.
    ğŸ‘‰Fleradiga kommentarer kan skrivas med flera #-rader eller som docstrings (""" ... """).
  Indentering:
    ğŸ‘‰Python krÃ¤ver indentering fÃ¶r funktioner, loopar och villkor.
    ğŸ‘‰PEP 8 rekommenderar fyra mellanslag per nivÃ¥.
    ğŸ‘‰Exempel: en if inuti en while fÃ¥r totalt Ã¥tta mellanslag.
  Syntax:
    ğŸ‘‰Vanliga fel gÃ¤ller datatyper, rubriker och kolon.
    ğŸ‘‰StrÃ¤ngar ska ha citattecken, siffror och boolska vÃ¤rden ska inte.
    ğŸ‘‰Listor skrivs inom hakparenteser med komma mellan elementen.
    ğŸ‘‰Funktioner, loopar och villkor mÃ¥ste avslutas med kolon (:).
ğŸ‘‰ Kort sagt: FÃ¶lj PEP 8, kommentera tydligt, anvÃ¤nd korrekt indentering och var noga med syntaxen fÃ¶r att undvika fel och gÃ¶ra koden lÃ¤ttare att fÃ¶rstÃ¥.








Module 3 Work with strings and lists

I cybersÃ¤kerhet Ã¤r strings en av de vanligaste datatyperna i Python, eftersom de anvÃ¤nds fÃ¶r data som IP-adresser, anvÃ¤ndarnamn, URL:er och ID:n.
  Index och bracket notation:
    ğŸ‘‰Varje tecken i en string har ett index (0-baserat, kan vara negativt frÃ¥n slutet).
    ğŸ‘‰[] anvÃ¤nds fÃ¶r att extrahera tecken eller delar av en string (slicing).
    ğŸ‘‰Exempel: "h32rb17"[0] â†’ "h", "h32rb17"[0:3] â†’ "h32".
  Stringfunktioner och metoder:
    ğŸ‘‰str() â†’ konverterar vÃ¤rden till string.
    ğŸ‘‰len() â†’ returnerar antal tecken i string.
    ğŸ‘‰.upper() / .lower() â†’ returnerar en kopia av strings i stora respektive smÃ¥ bokstÃ¤ver.
    ğŸ‘‰.index() â†’ returnerar index fÃ¶r fÃ¶rsta fÃ¶rekomsten av ett tecken eller substring; ger fel om det inte finns.
  Praktisk anvÃ¤ndning i cybersÃ¤kerhet:
    ğŸ‘‰Extrahera delar av IP-adresser eller ID:n.
    ğŸ‘‰Verifiera att anvÃ¤ndarnamn eller enheter uppfyller kriterier.
    ğŸ‘‰Hitta substrings fÃ¶r att analysera loggar eller aktivitet.
ğŸ‘‰Kort sagt: Kunskap om strings, indexering, slicing och metoder som .upper(), .lower() och .index() Ã¤r viktiga verktyg fÃ¶r en sÃ¤kerhetsanalytiker.


Som sÃ¤kerhetsanalytiker anvÃ¤nder man ofta listor i Python fÃ¶r att lagra data som exempelvis anvÃ¤ndarnamn, IP-adresser, URL:er och enhets-ID:n. 
Listor kan innehÃ¥lla olika datatyper och gÃ¶r det mÃ¶jligt att arbeta med flera element i en och samma variabel.
  ğŸ‘‰Indexering: Varje element i en lista har ett index som bÃ¶rjar pÃ¥ 0. Man kan anvÃ¤nda hakparenteser fÃ¶r att hÃ¤mta, Ã¤ndra eller skapa delmÃ¤ngder (slices) av listan. Till skillnad frÃ¥n strÃ¤ngar kan listor Ã¤ndras.
  ğŸ‘‰Ã„ndra element: Genom att anvÃ¤nda hakparenteser kan man byta ut ett specifikt element i listan.
  Metoder:
    .insert() â€“ lÃ¤gger till ett element pÃ¥ en specifik plats.
    .remove() â€“ tar bort den fÃ¶rsta fÃ¶rekomsten av ett element.
    .append() â€“ lÃ¤gger till ett element i slutet av listan, ofta anvÃ¤ndbart i loopar.
    .index() â€“ returnerar index fÃ¶r den fÃ¶rsta fÃ¶rekomsten av ett element.
ğŸ‘‰Sammanfattningsvis Ã¤r listor flexibla datatyper som gÃ¶r det mÃ¶jligt att strukturera och bearbeta data effektivt, vilket Ã¤r sÃ¤rskilt anvÃ¤ndbart i ett sÃ¤kerhetsanalytikers arbete.



ReguljÃ¤ra uttryck (regex) i Python anvÃ¤nds fÃ¶r att sÃ¶ka efter mÃ¶nster i text, exempelvis IP-adresser, e-postadresser eller enhets-ID:n. 
FÃ¶r att anvÃ¤nda dem importeras re-modulen, dÃ¤r funktionen re.findall() returnerar en lista med alla matchningar fÃ¶r ett givet mÃ¶nster.
  Teckentyper:
    \w â€“ alfanumeriska tecken (inklusive _)
    \d â€“ siffror [0â€“9]
    \s â€“ mellanslag
    . â€“ alla tecken
    \. â€“ punkttecknet
  Exempel:
    re.findall(r"\d", "h32rb17") output => ['3', '2', '1', '7']

  Men ibland vill du matcha flera siffror i rad, inte bara en. DÃ¤r kommer + och * in.
    \d+ â†’ matchar en eller fler siffror i rad
    Exempel:
      re.findall(r"\d+", "h32rb17") output => ['32', '17']

    \d* â†’ matchar noll eller fler siffror (alltsÃ¥ Ã¤ven tomma strÃ¤ngar dÃ¤r inga siffror finns)
    Exempel:
      re.findall(r"\d*", "h32rb17") output => ['32', '', '', '17', '']

  ğŸ”‘ Skillnaden:
    + betyder minst en gÃ¥ng (1 eller fler).
    * betyder noll eller fler gÃ¥nger (0, 1 eller fler).

    Kan ocksÃ¥ anvÃ¤nda steps fÃ¶r att fÃ¥ ihop stÃ¶rre sifferor, exempel:
      re.findall("\d{2}", "h32rb17 k825t0m c2994eh") output => ['32', '17', '82', '29', '94']
      re.findall("\d{1,3}", "h32rb17 k825t0m c2994eh") output => ['32', '17', '825', '0', '299', '4']

    NÃ¤r du skriver flera regex-delar i samma pattern sÃ¥ betyder det helt enkelt att Python ska matcha den exakta fÃ¶ljden av delmÃ¶nster.
      Exempel: \w+:\s\d+
        ğŸ‘‰ Det betyder:
            \w+ â†’ ett eller flera bokstÃ¤ver/siffror/underscore (t.ex. ett anvÃ¤ndarnamn)
            : â†’ ett kolon
            \s â†’ ett mellanslag
            \d+ â†’ en eller flera siffror

    I ett exempel:

      text = "1001 bmoreno: 12 Marketing 1002 tshah: 7 HR 1003 sgilmore: 5 Finance"
      matches = re.findall(r"\w+:\s\d+", text)
      print(matches) output => ['bmoreno: 12', 'tshah: 7', 'sgilmore: 5']







Module 4 Python in practice

Automatisering av sÃ¤kerhet i CI/CD med Python
  Genom att anvÃ¤nda Python i CI/CD-pipelines kan sÃ¤kerhet byggas in direkt i utvecklings- och leveransprocessen, vilket kallas DevSecOps. 
  MÃ¥let Ã¤r att gÃ¶ra sÃ¤kerhet till en delad ansvarspunkt och automatisera kontroller i varje steg.

  FÃ¶rdelar med att anvÃ¤nda Python i CI/CD:
    ğŸ‘‰Snabbare och mer effektiv utveckling
    ğŸ‘‰UpptÃ¤cker problem tidigt och minskar kostnader
    ğŸ‘‰SÃ¤kerstÃ¤ller konsekventa kontroller
    ğŸ‘‰Minskar sÃ¤kerhetsteamets arbetsbÃ¶rda
    ğŸ‘‰StÃ¤rker en sÃ¤kerhetskultur i organisationen

  Exempel pÃ¥ uppgifter som kan automatiseras med Python:
    SÃ¤kerhetstester:
      ğŸ‘‰SAST (granska kÃ¤llkod innan bygge)
      ğŸ‘‰DAST (testa kÃ¶rande program i testmiljÃ¶)
      ğŸ‘‰SCA (kontrollera beroenden och tredjepartskod
    SÃ¥rbarhetsskanning: av containerbilder, infrastruktur och pipelines
    Efterlevnadskontroller: jÃ¤mfÃ¶ra mot sÃ¤kerhetsregler och standarder
    Hantering av hemligheter: undvika hÃ¥rdkodade lÃ¶senord, integrera med verktyg som Vault
    Policy enforcement: stoppa releaser som bryter mot definierade sÃ¤kerhetspolicys

  Integration med CI/CD-verktyg:
  Python kan enkelt anvÃ¤ndas i Jenkins, GitLab CI och CircleCI genom att:
    ğŸ‘‰KÃ¶ra skript som pipeline-steg
    ğŸ‘‰Anropa API:er fÃ¶r att starta jobb och analysera resultat
    ğŸ‘‰Utnyttja add-ons/extensioner som stÃ¶djer Python

  Andra anvÃ¤ndningsomrÃ¥den:
    Automatisera sÃ¤kra miljÃ¶er (staging/produktion)
    Kontrollera kodkvalitet (linters, kodstandarder)
    Hantera sÃ¤kra releaser

  Slutsats:
    Python Ã¤r en stark partner i CI/CD-sÃ¤kerhet. Det gÃ¶r det mÃ¶jligt att hitta problem tidigt, minska manuella uppgifter, 
    sÃ¤kerstÃ¤lla efterlevnad och bygga en DevSecOps-kultur dÃ¤r sÃ¤kerhet Ã¤r inbyggd i hela utvecklingsprocessen.



GrundlÃ¤ggande Python-komponenter fÃ¶r automation
  Automation innebÃ¤r att minska manuellt arbete genom att lÃ¥ta tekniken utfÃ¶ra repetitiva uppgifter. Som sÃ¤kerhetsanalytiker anvÃ¤nds 
  Python fÃ¶r att automatisera uppgifter som att undersÃ¶ka inloggningar, hantera Ã¥tkomst och uppdatera enheter.

  De viktigaste komponenterna fÃ¶r automation i Python Ã¤r:
    ğŸ‘‰Variabler â€“ lagrar data som anvÃ¤nds i automatiserade processer.
    ğŸ‘‰Villkorssatser (if) â€“ kontrollerar om vissa villkor uppfylls innan en Ã¥tgÃ¤rd utfÃ¶rs.
    ğŸ‘‰Iterativa satser (loopar) â€“ upprepar kod flera gÃ¥nger:
    ğŸ‘‰for-loopar itererar Ã¶ver en sekvens.
    ğŸ‘‰while-loopar upprepar baserat pÃ¥ ett villkor.
    ğŸ‘‰Funktioner â€“ gÃ¶r koden Ã¥teranvÃ¤ndbar och strukturerad.
    ğŸ‘‰StrÃ¤nghantering â€“ metoder och funktioner som len(), .index() och hakparenteser fÃ¶r att extrahera och bearbeta text.
    ğŸ‘‰Listor â€“ vanliga datastrukturer i sÃ¤kerhetsautomation, med metoder som .append(), .remove(), .insert(), och .index().

  Exempel: Vid analys av en flaggad anvÃ¤ndare kan man rÃ¤kna antalet inloggningar genom att:
    1. Iterera Ã¶ver en lista med anvÃ¤ndarnamn.
    2. Kontrollera om varje anvÃ¤ndarnamn matchar den flaggade anvÃ¤ndaren.
    3. Ã–ka en rÃ¤knare vid varje trÃ¤ff.
    4. Packa koden i en funktion fÃ¶r Ã¥teranvÃ¤ndning.

  Filer i Python:
    En central del av sÃ¤kerhetsautomation Ã¤r att arbeta med loggfiler (.txt och .csv).
      ğŸ‘‰.txt â€“ innehÃ¥ller text utan fast struktur.
      ğŸ‘‰.csv â€“ innehÃ¥ller data separerad med kommatecken.
  Python kan importera, lÃ¤sa, skriva och strukturera data frÃ¥n dessa filer, vilket Ã¤r viktigt fÃ¶r logghantering och analys.



Importera och arbeta med filer i Python
  FÃ¶r sÃ¤kerhetsanalytiker Ã¤r filer â€“ sÃ¤rskilt loggfiler â€“ centrala vid analys av systemhÃ¤ndelser, inloggningsfÃ¶rsÃ¶k och programvaruproblem. 
  Python kan Ã¶ppna, lÃ¤sa och skriva filer, vilket gÃ¶r filhantering till en viktig del av automation inom cybersÃ¤kerhet.

  Ã–ppna filer
    Syntax:
      with open("filnamn.txt", "r") as file:

    with => ser till att filen stÃ¤ngs korrekt.
    open() => tar tvÃ¥ argument: filnamn/filvÃ¤g och lÃ¤ge:
      "r" â†’ lÃ¤sa (read)
      "w" â†’ skriva (write, skriver Ã¶ver innehÃ¥llet eller skapar ny fil)
      "a" â†’ lÃ¤gga till (append, skriver till slutet av filen)
    as => anvÃ¤nds fÃ¶r att tilldela en variabel som representerar filen under blocket.

  FilvÃ¤gar
    Om filen ligger i samma katalog rÃ¤cker filnamnet.
    Om filen ligger i en annan katalog krÃ¤vs en absolut sÃ¶kvÃ¤g.
    FilvÃ¤gar och filnamn skrivs som strÃ¤ngar i citattecken.


  LÃ¤sa filer
    .read() â†’ konverterar innehÃ¥llet till en strÃ¤ng.
    Syntax:
      with open("update_log.txt", "r") as file:
          updates = file.read()
      print(updates)

    NÃ¤r filen Ã¤r lÃ¤st kan man anvÃ¤nda vanliga strÃ¤ngmetoder, t.ex. .index() eller len().
    Skriva och uppdatera filer
      "w" â†’ skapar eller skriver Ã¶ver fil.
      "a" â†’ lÃ¤gger till information lÃ¤ngst ned i filen.
      .write() => anvÃ¤nds fÃ¶r att skriva strÃ¤ngar till filen.
    Syntax:
      line = "user,192.168.1.1,10:45:00,True"
      with open("access_log.txt", "a") as file:
          file.write(line)

  Sammanfattning:
    ğŸ‘‰.LÃ¤sning (r) anvÃ¤nds fÃ¶r att analysera loggar.
    ğŸ‘‰.Skrivning (w) anvÃ¤nds fÃ¶r att skapa nya eller ersÃ¤tta filer.
    ğŸ‘‰.TillÃ¤gg (a) anvÃ¤nds fÃ¶r att lÃ¤gga till data utan att ta bort befintligt innehÃ¥ll.
    ğŸ‘‰.with open() Ã¤r den sÃ¤kraste metoden eftersom filen stÃ¤ngs automatiskt.



Arbeta med filer i Python â€“ parsing, .split() och .join()
  NÃ¤r man arbetar med filer i Python behÃ¶ver innehÃ¥llet ibland struktureras om. Parsing innebÃ¤r att gÃ¶ra data mer lÃ¤sbar eller anvÃ¤ndbar, 
  antingen fÃ¶r Python-kod eller fÃ¶r mÃ¤nniskor. TvÃ¥ centrala metoder fÃ¶r detta Ã¤r .split() och .join().

  .join()
  GÃ¶r det motsatta: slÃ¥r ihop en lista till en strÃ¤ng, med en vald separator.
    Exempel:
      ",".join(['anna', 'bob', 'carl']) => "anna,bob,carl"
      "\n".join(['anna', 'bob', 'carl']) => radseparerad text
    NÃ¶dvÃ¤ndigt om man vill skriva tillbaka en lista till en fil med .write(), eftersom .write() bara hanterar strÃ¤ngar.
    TillÃ¤mpning pÃ¥ filer
    1. LÃ¤s filinnehÃ¥ll:
      with open("update_log.txt", "r") as file:
      updates = file.read().split() => filens innehÃ¥ll blir en lista.
    2. Bearbeta listan (t.ex. lÃ¤gga till/ta bort element).
    3. Skriv tillbaka:
      with open("update_log.txt", "w") as file:
      file.write(" ".join(updates)) â†’ listan konverteras till en strÃ¤ng och sparas i filen.

  ğŸ‘‰ Kort sagt:
    .split() = strÃ¤ng â†’ lista (bra fÃ¶r analys & iteration).
    .join() = lista â†’ strÃ¤ng (bra fÃ¶r att skriva till filer).
























































